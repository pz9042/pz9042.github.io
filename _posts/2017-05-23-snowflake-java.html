---
layout: article
title:  "snowflake java 实现"
tags: snowflake uuid
date: 2017-05-26 14:08:01 -0600
categories: 拓展
---
<div id='preview-contents' class='note-content'>
                        

<h1 id="snowflake-java实现">snowflake java实现</h1>

<div><div class="toc"><div class="toc">
<ul>
<li><a href="#snowflake-java实现">snowflake java实现</a><ul>
<li><a href="#概述">概述</a></li>
<li><a href="#结构">结构</a></li>
<li><a href="#源码">源码</a></li>
</ul>
</li>
</ul>
</div>
</div>
</div>

<h2 id="概述">概述</h2>

<p>分布式系统中，有一些需要使用全局唯一ID的场景，这种时候为了防止ID冲突可以使用36位的UUID，但是UUID有一些缺点，首先他相对比较长，另外UUID一般是无序的。有些时候我们希望能使用一种简单一些的ID，并且希望ID能够按照时间有序生成。而twitter的snowflake解决了这种需求，最初Twitter把存储系统从MySQL迁移到Cassandra，因为Cassandra没有顺序ID生成机制，所以开发了这样一套全局唯一ID生成服务。</p>

<h2 id="结构">结构</h2>

<p>snowflake的结构如下(每部分用-分开)： <br>
<code>0-0000000000 0000000000 0000000000 0000000000 0-00000-00000-000000000000</code> <br>
第一位为未使用，接下来的41位为毫秒级时间(41位的长度可以使用69年)，然后是5位datacenterId和5位workerId(10位的长度最多支持部署1024个节点） ，最后12位是毫秒内的计数（12位的计数顺序号支持每个节点每毫秒产生4096个ID序号） <br>
一共加起来刚好64位，为一个Long型。(转换成字符串长度为18)，<strong>snowflake </strong> 生成的ID整体上按照时间自增排序，并且整个分布式系统内不会产生ID碰撞（由datacenter和workerId作区分），并且效率较高。据说：snowflake每秒能够产生26万个ID。</p>

<hr>

<h2 id="源码">源码</h2>

<p>-<code>JAVA版本的源码</code></p>



<pre class="prettyprint hljs-dark"><code class="language-java hljs"><span class="hljs-comment">/**<br>* Twitter_Snowflake&lt;br&gt;<br>* SnowFlake的结构如下(每部分用-分开):&lt;br&gt;<br>* 0 - 0000000000 0000000000 0000000000 0000000000 0 - 00000 - 00000 - 000000000000 &lt;br&gt;<br>* 1位标识，由于long基本类型在Java中是带符号的，最高位是符号位，正数是0，负数是1，所以id一般是正数，最高位是0&lt;br&gt;<br>* 41位时间截(毫秒级)，注意，41位时间截不是存储当前时间的时间截，而是存储时间截的差值（当前时间截 - 开始时间截)<br>* 得到的值），这里的的开始时间截，一般是我们的id生成器开始使用的时间，由我们程序来指定的（如下下面程序IdWorker类的startTime属性）。41位的时间截，可以使用69年，年T = (1L &lt;&lt; 41) / (1000L * 60 * 60 * 24 * 365) = 69&lt;br&gt;<br>* 10位的数据机器位，可以部署在1024个节点，包括5位datacenterId和5位workerId&lt;br&gt;<br>* 12位序列，毫秒内的计数，12位的计数顺序号支持每个节点每毫秒(同一机器，同一时间截)产生4096个ID序号&lt;br&gt;<br>* 加起来刚好64位，为一个Long型。&lt;br&gt;<br>* SnowFlake的优点是，整体上按照时间自增排序，并且整个分布式系统内不会产生ID碰撞(由数据中心ID和机器ID作区分)，并且效率较高，经测试，SnowFlake每秒能够产生26万ID左右。<br>*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SnowflakeIdWorker</span> </span>{<br><br>    <span class="hljs-comment">// ==============================Fields===========================================</span><br>    <span class="hljs-comment">/** 开始时间截 (2015-01-01) */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> twepoch = <span class="hljs-number">1420041600000L</span>;<br><br>    <span class="hljs-comment">/** 机器id所占的位数 */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> workerIdBits = <span class="hljs-number">5L</span>;<br><br>    <span class="hljs-comment">/** 数据标识id所占的位数 */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> datacenterIdBits = <span class="hljs-number">5L</span>;<br><br>    <span class="hljs-comment">/** 支持的最大机器id，结果是31 (这个移位算法可以很快的计算出几位二进制数所能表示的最大十进制数) */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> maxWorkerId = -<span class="hljs-number">1L</span> ^ (-<span class="hljs-number">1L</span> &lt;&lt; workerIdBits);<br><br>    <span class="hljs-comment">/** 支持的最大数据标识id，结果是31 */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> maxDatacenterId = -<span class="hljs-number">1L</span> ^ (-<span class="hljs-number">1L</span> &lt;&lt; datacenterIdBits);<br><br>    <span class="hljs-comment">/** 序列在id中占的位数 */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> sequenceBits = <span class="hljs-number">12L</span>;<br><br>    <span class="hljs-comment">/** 机器ID向左移12位 */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> workerIdShift = sequenceBits;<br><br>    <span class="hljs-comment">/** 数据标识id向左移17位(12+5) */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> datacenterIdShift = sequenceBits + workerIdBits;<br><br>    <span class="hljs-comment">/** 时间截向左移22位(5+5+12) */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> timestampLeftShift = sequenceBits + workerIdBits + datacenterIdBits;<br><br>    <span class="hljs-comment">/** 生成序列的掩码，这里为4095 (0b111111111111=0xfff=4095) */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> sequenceMask = -<span class="hljs-number">1L</span> ^ (-<span class="hljs-number">1L</span> &lt;&lt; sequenceBits);<br><br>    <span class="hljs-comment">/** 工作机器ID(0~31) */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">long</span> workerId;<br><br>    <span class="hljs-comment">/** 数据中心ID(0~31) */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">long</span> datacenterId;<br><br>    <span class="hljs-comment">/** 毫秒内序列(0~4095) */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">long</span> sequence = <span class="hljs-number">0L</span>;<br><br>    <span class="hljs-comment">/** 上次生成ID的时间截 */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">long</span> lastTimestamp = -<span class="hljs-number">1L</span>;<br><br>    <span class="hljs-comment">//==============================Constructors=====================================</span><br>    <span class="hljs-comment">/**<br>    * 构造函数<br>    * <span class="hljs-doctag">@param</span> workerId 工作ID (0~31)<br>    * <span class="hljs-doctag">@param</span> datacenterId 数据中心ID (0~31)<br>    */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SnowflakeIdWorker</span><span class="hljs-params">(<span class="hljs-keyword">long</span> workerId, <span class="hljs-keyword">long</span> datacenterId)</span> </span>{<br>        <span class="hljs-keyword">if</span> (workerId &gt; maxWorkerId || workerId &lt; <span class="hljs-number">0</span>) {<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(String.format(<span class="hljs-string">"worker Id can't be greater than %d or less than 0"</span>, maxWorkerId));<br>        }<br>        <span class="hljs-keyword">if</span> (datacenterId &gt; maxDatacenterId || datacenterId &lt; <span class="hljs-number">0</span>) {<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(String.format(<span class="hljs-string">"datacenter Id can't be greater than %d or less than 0"</span>, maxDatacenterId));<br>        }<br>        <span class="hljs-keyword">this</span>.workerId = workerId;<br>        <span class="hljs-keyword">this</span>.datacenterId = datacenterId;<br>    }<br><br>    <span class="hljs-comment">// ==============================Methods==========================================</span><br>    <span class="hljs-comment">/**<br>    * 获得下一个ID (该方法是线程安全的)<br>    * <span class="hljs-doctag">@return</span> SnowflakeId<br>    */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">long</span> <span class="hljs-title">nextId</span><span class="hljs-params">()</span> </span>{<br>        <span class="hljs-keyword">long</span> timestamp = timeGen();<br><br>        <span class="hljs-comment">//如果当前时间小于上一次ID生成的时间戳，说明系统时钟回退过这个时候应当抛出异常</span><br>        <span class="hljs-keyword">if</span> (timestamp &lt; lastTimestamp) {<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<br>                    String.format(<span class="hljs-string">"Clock moved backwards.  Refusing to generate id for %d milliseconds"</span>, lastTimestamp - timestamp));<br>        }<br><br>        <span class="hljs-comment">//如果是同一时间生成的，则进行毫秒内序列</span><br>        <span class="hljs-keyword">if</span> (lastTimestamp == timestamp) {<br>            sequence = (sequence + <span class="hljs-number">1</span>) &amp; sequenceMask;<br>            <span class="hljs-comment">//毫秒内序列溢出</span><br>            <span class="hljs-keyword">if</span> (sequence == <span class="hljs-number">0</span>) {<br>                <span class="hljs-comment">//阻塞到下一个毫秒,获得新的时间戳</span><br>                timestamp = tilNextMillis(lastTimestamp);<br>            }<br>        }<br>        <span class="hljs-comment">//时间戳改变，毫秒内序列重置</span><br>        <span class="hljs-keyword">else</span> {<br>            sequence = <span class="hljs-number">0L</span>;<br>        }<br><br>        <span class="hljs-comment">//上次生成ID的时间截</span><br>        lastTimestamp = timestamp;<br><br>        <span class="hljs-comment">//移位并通过或运算拼到一起组成64位的ID</span><br>        <span class="hljs-keyword">return</span> ((timestamp - twepoch) &lt;&lt; timestampLeftShift) <span class="hljs-comment">//</span><br>                | (datacenterId &lt;&lt; datacenterIdShift) <span class="hljs-comment">//</span><br>                | (workerId &lt;&lt; workerIdShift) <span class="hljs-comment">//</span><br>                | sequence;<br>    }<br><br>    <span class="hljs-comment">/**<br>    * 阻塞到下一个毫秒，直到获得新的时间戳<br>    * <span class="hljs-doctag">@param</span> lastTimestamp 上次生成ID的时间截<br>    * <span class="hljs-doctag">@return</span> 当前时间戳<br>    */</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">long</span> <span class="hljs-title">tilNextMillis</span><span class="hljs-params">(<span class="hljs-keyword">long</span> lastTimestamp)</span> </span>{<br>        <span class="hljs-keyword">long</span> timestamp = timeGen();<br>        <span class="hljs-keyword">while</span> (timestamp &lt;= lastTimestamp) {<br>            timestamp = timeGen();<br>        }<br>        <span class="hljs-keyword">return</span> timestamp;<br>    }<br><br>    <span class="hljs-comment">/**<br>    * 返回以毫秒为单位的当前时间<br>    * <span class="hljs-doctag">@return</span> 当前时间(毫秒)<br>    */</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">long</span> <span class="hljs-title">timeGen</span><span class="hljs-params">()</span> </span>{<br>        <span class="hljs-keyword">return</span> System.currentTimeMillis();<br>    }<br><br>    <span class="hljs-comment">//==============================Test=============================================</span><br>    <span class="hljs-comment">/** 测试 */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>        SnowflakeIdWorker idWorker = <span class="hljs-keyword">new</span> SnowflakeIdWorker(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++) {<br>            <span class="hljs-keyword">long</span> id = idWorker.nextId();<br>            System.out.println(Long.toBinaryString(id));<br>            System.out.println(id);<br>        }<br>    }<br>}<br></code></pre></div></body></html>